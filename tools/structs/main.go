package main

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"go/token"
	"io"
	"log/slog"
	"maps"
	"net/http"
	"os"
	"reflect"
	"slices"
	"strings"
	"time"

	"github.com/carlohamalainen/antarctic-database-go/cache"

	"github.com/dave/dst"
	"github.com/dave/dst/decorator"

	"golang.org/x/text/cases"
	"golang.org/x/text/language"
)

// structInfo stores the names and fields of Go structures derived from
// raw json data. This is an intermediate data structure, used as input
// to the code generator [generateGoCode].
type structInfo struct {
	name   string
	fields []*dst.Field
}

var caser = cases.Title(language.Und)

// generateGoStructs maps from unmarshalled json to [[]structInfo].
func generateGoStructs(data interface{}, name string) []structInfo {
	var structs []structInfo
	fields := []*dst.Field{}

	switch v := data.(type) {
	case map[string]interface{}:
		for key, value := range v {
			fieldName := caser.String(key)
			var fieldType dst.Expr

			switch typedValue := value.(type) {
			case string:
				fieldType = &dst.Ident{Name: "string"}
			case float64:
				// interpreting all numeric fields as integers
				fieldType = &dst.Ident{Name: "int"}
			case bool:
				fieldType = &dst.Ident{Name: "bool"}
			case nil:
				fieldType = &dst.Ident{Name: "interface{}"}
			case map[string]interface{}:
				nestedStructName := name + fieldName
				fieldType = &dst.Ident{Name: nestedStructName}
				nestedStructs := generateGoStructs(typedValue, nestedStructName)
				structs = append(structs, nestedStructs...)
			case []interface{}:
				// If we have a nonempty list of things we can try to determine their types - loop through all the values.
				if len(typedValue) > 0 {
					for idxTypedValue := range len(typedValue) {
						sliceType := reflect.TypeOf(typedValue[idxTypedValue])
						if sliceType == reflect.TypeOf(map[string]interface{}{}) {
							nestedStructName := name + fieldName + "Item"
							fieldType = &dst.ArrayType{Elt: &dst.Ident{Name: nestedStructName}}
							nestedStructs := generateGoStructs(typedValue[idxTypedValue], nestedStructName)
							structs = append(structs, nestedStructs...)
						} else {
							fieldType = &dst.ArrayType{Elt: &dst.Ident{Name: sliceType.String()}}
						}
					}
				} else {
					// Otherwise just note this as an array of unknown.
					fieldType = &dst.ArrayType{Elt: &dst.Ident{Name: "interface{}"}}
				}
			default:
				fieldType = &dst.Ident{Name: "interface{}"}
			}

			fields = append(fields, &dst.Field{
				Names: []*dst.Ident{{Name: fieldName}},
				Type:  fieldType,
				Tag:   &dst.BasicLit{Kind: token.STRING, Value: fmt.Sprintf("`json:\"%s\"`", key)},
			})
		}
	default:
		panic(fmt.Errorf("What happened, what is this type? %+v", data))
	}

	structs = append(structs, structInfo{name: name, fields: fields})
	return structs
}

// generateGoCode generates and formats the api module.
func generateGoCode(structs []structInfo) ([]byte, error) {
	var decls []dst.Decl

	// if _, err := buf.WriteString("// AUTOGENERATED FILE! Do not edit!\n\n"); err != nil {

	for _, st := range structs {
		slog.Info("generating struct", "name", st.name)

		slices.SortFunc(st.fields, func(a, b *dst.Field) int {
			return strings.Compare(a.Names[0].Name, b.Names[0].Name)
		})

		decls = append(decls, &dst.GenDecl{
			Tok: token.TYPE,
			Specs: []dst.Spec{
				&dst.TypeSpec{
					Name: &dst.Ident{Name: st.name},
					Type: &dst.StructType{
						Fields: &dst.FieldList{
							List: st.fields,
						},
					},
				},
			},
		})
	}

	f := &dst.File{
		Name:  &dst.Ident{Name: "ats"},
		Decls: decls,
		Decs: dst.FileDecorations{
			NodeDecs: dst.NodeDecs{
				Start: []string{"// AUTOGENERATED FILE! Do not edit!", "\n"},
			},
		},
	}

	// dstutil.Apply(f, nil, nil)

	var buf bytes.Buffer

	decorator.Fprint(&buf, f)

	return buf.Bytes(), nil
}

func download(ctx context.Context, url string) (map[string]interface{}, error) {
	ctx, cancel := context.WithTimeout(ctx, 10*time.Second) // FIXME timeouts should be a setting
	defer cancel()

	slog.Info("downloading", "url", url)

	req, err := http.NewRequestWithContext(ctx, http.MethodGet, url, nil)
	if err != nil {
		slog.Error("request error", "error", err)
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	client, err := cache.NewHTTPClient(nil)
	if err != nil {
		return nil, err
	}
	if client == nil {
		return nil, fmt.Errorf("failed to create new http client")
	}

	resp, err := client.Do(req)
	if err != nil {
		slog.Error("error making request", "error", err)
		return nil, fmt.Errorf("error making the request: %w", err)
	}
	if resp == nil {
		return nil, fmt.Errorf("nil response")
	}
	defer resp.Body.Close()

	if resp.StatusCode != http.StatusOK {
		slog.Error("unexpected status code", "status_code", resp.StatusCode)
		return nil, fmt.Errorf("unexpected status code: got %v", resp.StatusCode)
	}

	body, err := io.ReadAll(resp.Body)
	if err != nil {
		slog.Error("error reading response", "error", err)
		return nil, fmt.Errorf("error reading the response: %w", err)
	}

	var result map[string]interface{}
	err = json.Unmarshal(body, &result)
	if err != nil {
		slog.Error("error unmarshalling json", "error", err)
		return nil, fmt.Errorf("error parsing JSON: %w", err)
	}

	return result, nil
}

func merge(a []structInfo, b []structInfo) ([]structInfo, error) {
	merged := make(map[string]structInfo)

	addOrMerge := func(si structInfo) error {
		if existing, ok := merged[si.name]; ok {
			// Merge fields
			fieldMap := make(map[string]*dst.Field)
			for _, field := range existing.fields {
				fieldMap[field.Names[0].Name] = field
			}

			for _, newField := range si.fields {
				name := newField.Names[0].Name
				if existingField, ok := fieldMap[name]; ok {
					// Field exists, check if types match
					if !reflect.DeepEqual(existingField.Type, newField.Type) {

						switch {
						// Types don't match, prefer concrete type over interface{}
						case isInterface(existingField.Type) && !isInterface(newField.Type):
							fieldMap[name] = newField

						// Keep existing concrete type
						case !isInterface(existingField.Type) && isInterface(newField.Type):

						// Types don't match, prefer concrete type over []interface{}
						case isArrayOfInterface(existingField.Type) && !isArrayOfInterface(newField.Type):
							fieldMap[name] = newField

						// Keep existing concrete type
						case !isArrayOfInterface(existingField.Type) && isArrayOfInterface(newField.Type):

						default:
							slog.Error("type mismatch", "name", name, "struct", si.name, "existing_type", existingField.Type, "new_type", newField.Type)
							return fmt.Errorf("type mismatch for field %s in struct %s", name, si.name)
						}
					}
				} else {
					// New field, add it
					fieldMap[name] = newField
				}
			}

			// Reconstruct fields slice
			merged[si.name] = structInfo{
				name:   si.name,
				fields: slices.Collect(maps.Values(fieldMap)),
			}
		} else {
			// New struct, add it
			merged[si.name] = si
		}
		return nil
	}

	// Merge structs from slice a
	for _, si := range a {
		if err := addOrMerge(si); err != nil {
			return nil, err
		}
	}

	// Merge structs from slice b
	for _, si := range b {
		if err := addOrMerge(si); err != nil {
			return nil, err
		}
	}

	result := make([]structInfo, 0, len(merged))
	for _, si := range merged {
		result = append(result, si)
	}

	return result, nil
}

func isInterface(t dst.Expr) bool {
	if ident, ok := t.(*dst.Ident); ok {
		return ident.Name == "interface{}"
	}
	return false
}

func isArrayOfInterface(t dst.Expr) bool {
	if array, ok := t.(*dst.ArrayType); ok {
		if ident, ok := array.Elt.(*dst.Ident); ok {
			return ident.Name == "interface{}"
		}
	}
	return false
}

func main() {
	ctx := context.Background()
	logger := slog.New(slog.NewTextHandler(os.Stdout, nil))
	slog.SetDefault(logger)

	urls := [][2]string{
		// Meeting documents
		{"Document", "https://www.ats.aq/devAS/Meetings/SearchDocDatabase?meeting=1&from=0&to=0&party=0&type=1&category=0&title=&page=1"},
		{"Document", "https://www.ats.aq/devAS/Meetings/SearchDocDatabase?meeting=1&from=0&to=0&party=0&type=1&category=0&title=&page=2"},
		{"Document", "https://www.ats.aq/devAS/Meetings/SearchDocDatabase?meeting=1&from=0&to=0&party=0&type=1&category=0&title=&page=3"},

		// Treaty database
		{"Treaty", "https://www.ats.aq/devAS/ToolsAndResources/SearchDatabase?from=1/1/1958&to=1/1/2158&cat=0&top=0&type=0&stat=0&txt=&curr=0&page=1"},
		{"Treaty", "https://www.ats.aq/devAS/ToolsAndResources/SearchDatabase?from=1/1/1958&to=1/1/2158&cat=0&top=0&type=0&stat=0&txt=&curr=0&page=2"},
		{"Treaty", "https://www.ats.aq/devAS/ToolsAndResources/SearchDatabase?from=1/1/1958&to=1/1/2158&cat=0&top=0&type=0&stat=0&txt=&curr=0&page=3"},
	}

	structs := make([][]structInfo, 0)

	for i, url := range urls {
		result, err := download(ctx, url[1])
		if err != nil {
			panic(err)
		}
		slog.Info("generating go structs", "offset", i)
		structs = append(structs, generateGoStructs(result, url[0]))
	}

	if len(structs) == 0 {
		panic("empty sample structs")
	}

	// foldl1
	merged := structs[0]
	for i := 1; i < len(structs); i++ {
		slog.Info("merging struct", "offset", i)
		var err error
		merged, err = merge(merged, structs[i])
		if err != nil {
			panic(err)
		}
	}

	slices.SortFunc(merged, func(a, b structInfo) int {
		return strings.Compare(a.name, b.name)
	})

	for _, s := range merged {
		for _, f := range s.fields {
			if isInterface(f.Type) {
				panic("ambiguous field " + s.name + " with type interface{}")
			}
		}
	}

	formattedCode, err := generateGoCode(merged)
	if err != nil {
		panic(err)
	}

	slog.Info("writing generated code", "filename", "structs.go")
	errWrite := os.WriteFile("structs.go", formattedCode, 0644)
	if errWrite != nil {
		panic(errWrite)
	}
}
